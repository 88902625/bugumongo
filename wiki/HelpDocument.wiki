#labels 帮助文档,Wiki
=使用前提=

1、需要JDK1.6以上

2、需要MongoDB Java Driver

3、需要log4j

4、需要Lucene 3.2

=1、对象-数据库映射=
在对象-数据库映射方面，BuguMongo提供了：

6个注解：@Entity、@Id、@Property、@Embed、@Ref、@RefList

3个类：BuguConnection、BuguDao、BuguMapper

1个接口：BuguEntity

它们的含义都很直观。BuguMongo的使用，就是围绕着上述注解、类和接口来进行。

==步骤一：定义Entity==
要使得某个Java Entity能和MongoDB Document实现相互转换，该Entity需要实现BuguEntity接口，并加上注解，如下：
{{{
import com.bugull.mongo.BuguEntity;
import com.bugull.mongo.annotations.Entity;
import com.bugull.mongo.annotations.Embed;
import com.bugull.mongo.annotations.Id;
import com.bugull.mongo.annotations.Property;
import com.bugull.mongo.annotations.Ref;
import com.bugull.mongo.annotations.RefList;
import java.util.List;

@Entity(name="foo")
public class Foo implements BuguEntity{
    @Id
    private String id;
    @Property
    private int level;
    @Embed
    private EmbedFoo embed;
    @Ref
    private FatherFoo father;
    @RefList
    private List<ChildFoo> children;
    ...getter and setter...
}

public class EmbedFoo {
    private float x;
    private float y;
    ...getter and setter
}

@Entity(name="father")
public class FatherFoo implements BuguEntity{
    @Id
    private String id;
    private Date date;
    ...getter and setter...
}

@Entity(name="child")
public class ChildFoo implements BuguEntity{
    @Id
    private String id;
    private List<String> list;
    ...getter and setter...
}
}}}
下面分别对这6个注解进行介绍
===@Entity===
表示需要映射到MongoDB中的一个实体，属性name表示其在MongoDB中的collection的名称。属性name是必需的。
===@Id===
映射到MongoDB中的"_id"，必须为String类型。
===@Property===
该注解可以省略。它用来映射基本数据类型，包括：String、int、long、float、double、boolean、char、Date等，以及这些基本数据类型组成的数组、List、Set。

@Property有一个属性name，用于指定映射到MongoDB collection中某个field。属性name可以省略，表示采用与Entity的Field相同的名称。
===@Embed===
表示该属性是一个嵌入的对象。
===@Ref===
表示对另一个对象的引用，在MongoDB中保存的是形如"father" : {"$ref" : "father", "$id" : ObjectId("4dcb4d1d3febc6503e4e5933")}这样的一个DBRef。

@Ref有一个属性name，含义与@Property的属性name一样。
@Ref还有一个属性lazy，值为true或false，默认为true。用于指定是否关联取出该引用对象。若lazy=true，表示只取出该引用对象的id，而不取出其它属性。若lazy=false，表示同时取出该引用对象的所有属性。
===@RefList===
表示对另一个对象的引用的集合。其属性name和lazy的含义与@Ref中的类似。

==步骤二：连接数据库==
在能够对MongDB进行操作之前，需要使用BuguConnection连接MongoDB数据库。如：
{{{
BuguConnection conn = BuguConnection.getInstance();
conn.setHost("192.168.0.100");
conn.setPort(27017);
conn.setDatabase("mydb");
conn.setUsername("username");
conn.setPassword("password");
conn.connect();
}}}
或者：
{{{
BuguConnection conn = BuguConnection.getInstance();
conn.connect("192.168.0.100", 27017, "mydb", "username", "password");
}}}

==步骤三：使用BuguDao进行数据库操作==
你需要编写自己的Dao，如FooDao，来操作Foo相关的数据，FooDao需要继承自BuguDao，并且，在FooDao的构造函数中，需要传递Foo.class，如下：
{{{
public class FooDao extends BuguDao{
    public FooDao(){
        super(Foo.class);
    }
}
}}}
BuguDao中，提供了大量的函数，用于操作MongoDB的Collection，如save、remove、find、count、mapReduce等。你自己编写的Dao，通过继承自BuguDao，可以直接调用这些方法，也可以通过组合这些方法，实现更复杂的函数。如：
{{{
public class FooDao extends BuguDao{
    public FooDao(){
        super(Foo.class);
    }
    public long coutByLowLevel(int level){
        DBObject query = new BasicDBObject();
        query.put("level", new BasicDBObject("$gt", level));
        return this.count(query);
    }
    ...other functions...
}
}}}
{{{
Foo foo = ...
FooDao fDao = new FooDao();
fDao.save(foo);
int count = fDao.countByLowLevel(9);
fDao.remove(foo);
}}}

==辅助转换工具：BuguMapper==
在某些地方，你需要使用BuguMapper来进行数据转换。BuguMapper提供了3个方法：fromDBObject、toDBObject、toDBRef。使用如下：
{{{
public class FooDao extends BuguDao{
    ...
    public Foo getByFather(FatherFoo father){
        DBObject query = new BasicDBObject();
        query.put("father", new BuguMapper().toDBRef(father));
        return (Foo)this.findOne(query);
    }
    ...
}
}}}

=2、Lucene索引=
在Lucene索引方面，BuguMongo提供了：

4个注解：@Indexed、@IndexProperty、@IndexEmbed、@IndexRef

3个类：BuguIndex、BuguParser、BuguSearcher

==步骤一：在Entity上加注解==

代码例子如下：

{{{
import com.bugull.mongo.BuguEntity;
import com.bugull.mongo.annotations.Entity;
import com.bugull.mongo.annotations.Embed;
import com.bugull.mongo.annotations.Id;
import com.bugull.mongo.annotations.Ref;
import com.bugull.mongo.lucene.annotations.Indexed;
import com.bugull.mongo.lucene.annotations.IndexProperty;
import com.bugull.mongo.lucene.annotations.IndexEmbed;
import com.bugull.mongo.lucene.annotations.IndexRef;
import java.util.List;

@Entity(name="foo")
@Indexed
public class Foo implements BuguEntity{
    @Id
    private String id;
    @IndexProperty(analyze=true, store=false)
    private String introduce;
    @Embed
    @IndexEmbed
    private EmbedFoo embed;
    @Ref
    @IndexRef
    private FatherFoo father;
    ...getter and setter...
}

public class EmbedFoo {
    @IndexProperty
    private float x;
    @IndexProperty
    private float y;
    ...getter and setter
}

@Entity(name="father")
public class FatherFoo implements BuguEntity{
    @Id
    private String id;
    @IndexProperty
    private String name;
    ...getter and setter...
}
}}}
各个注解的含义如下：

===@Indexed===
表示需要对该Entity建索引。该Entity上必须要有@Entity和@Id注解，@Indexed才能起作用。
===@IndexProperty===
表示需要索引的属性。该注解有2个参数：analyze和store，都是boolean型，analyze表示是否需要分词，store表示是否需要存储，默认值都是false。
String、char、boolean类型的属性，以字符串形式被索引。而int、long、float、double、Date类型的数据，通过NumericFiled，以数值的形式被索引。其中，Date类型会相应的转换成时间的long值。
===@IndexEmbed===
表示需要嵌入对该Embed属性的索引。
===@IndexRef===
表示需要嵌入对该Ref属性的索引。

==步骤二：设置索引参数==
代码例子如下：
{{{
BuguIndex index = BuguIndex.getInstance();
index.setAnalyzer(new StandardAnalyzer(Version.LUCENE_32));
index.setDirectoryType(DirectoryFactory.TYPE_FS);
index.setDirectoryPath("/root/lucene_index/");
index.startIndexReopenTask(30L*1000L);
}}}
代码中各个函数的含义都很直观。其中，startIndexReopenTask(long milli)的参数以毫秒为单位，表示索引刷新的时间周期，该参数值根据应用的情况而定，如30秒：30L*1000L。

==步骤三：搜索==
通过上面的设置，BuguMongo能够实现Entity和Lucene索引之间的自动同步，你只要实现搜索就行了。最基本的搜索的例子如下：
{{{
BuguSearcher searcher = new BuguSearcher(Foo.class);
BuguParser parser = new BuguParser();
Query query = parser.parse("introduce", "谷歌");
searcher.setQuery(query);
searcher.setSort(...);
searcher.setPageNumber(1);
searcher.setPageSize(20);
searcher.setMaxPage(50);
List list = searcher.search();
int count = searcher.getResultCount();
for(Object obj : list){
    Foo foo = (Foo)obj;
    ...
}
}}}
setMaxPage(maxPage)，表示最多返回搜索结果的前maxPage页，如果返回所有的搜索结果，当数据量太大的时候，会导致性能问题。pageNumber、pageSize、maxPage的值都可以不设置，默认值为分别为：1、20、50。

如果不排序，可以不用setSort()。

BuguParser还提供了MultiFieldQueryParser的功能。

对于通过@IndexEmbed和@IndexRef嵌入的索引，索引的field名称需要加上前缀，如：father.name，代码例子如下：
{{{
BuguSearcher searcher = new BuguSearcher(Foo.class);
BuguParser parser = new BuguParser();
Query query = parser.parse(new String[]{"introduce","father.name"},"谷歌");
searcher.setQuery(query);
List list = searcher.search();
int count = searcher.getResultCount();
for(Object obj : list){
    Foo foo = (Foo)obj;
    ...
}
}}}