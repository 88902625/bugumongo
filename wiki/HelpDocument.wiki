#summary 使用说明、帮助文档
#labels 使用说明,帮助文档,Wiki

=版本说明=
BuguMongo目前的版本是0.1，它使用：
  * JDK1.6
  * MongoDB Java Driver 2.6.3
  * Lucene 3.2
  * Log4j记录日志


=1、对象-数据库映射=
在对象-数据库映射方面，BuguMongo提供了：

8个注解：@Entity、@Id、@Property、@Embed、@EmbedList、@Ref、@RefList、@Ignore

3个类：BuguConnection、BuguDao、BuguMapper

1个接口：BuguEntity

它们的含义都很直观。BuguMongo的使用，就是围绕着上述注解、类和接口来进行。

==步骤一：定义Entity==
要使得某个Java Entity能和MongoDB Document实现相互转换，该Entity需要实现BuguEntity接口，并加上注解，如下：
{{{
import com.bugull.mongo.BuguEntity;
import com.bugull.mongo.annotations.Entity;
import com.bugull.mongo.annotations.Id;
import com.bugull.mongo.annotations.Property;
import com.bugull.mongo.annotations.Embed;
import com.bugull.mongo.annotations.EmbedList;
import com.bugull.mongo.annotations.Ref;
import com.bugull.mongo.annotations.RefList;
import java.util.List;

@Entity(name="foo")
public class Foo implements BuguEntity{
    @Id
    private String id;
    @Property
    private int level;
    @Embed
    private EmbedFoo embed;
    @EmbedList
    private List<EmbedFoo> embedList;
    @Ref
    private FatherFoo father;
    @RefList
    private List<ChildFoo> children;
    @Ignore
    private double sumScore;
    ...getter and setter...
}

public class EmbedFoo {
    private float x;
    private int y;
    ...getter and setter
}

@Entity(name="father")
public class FatherFoo implements BuguEntity{
    @Id
    private String id;
    private Date date;
    ...getter and setter...
}

@Entity(name="child")
public class ChildFoo implements BuguEntity{
    @Id
    private String id;
    private List<String> list;
    ...getter and setter...
}
}}}
各个注解的含义如下：
===@Entity===
表示需要映射到MongoDB中的一个实体，参数name表示其在MongoDB中的collection的名称。参数name可以省略，默认使用类名的全小写。

如果该实体对应的是Capped Collection，那么可以设置@Entity的参数capped=true，还可以设置capSize，默认为10M（10L*1024L*1024L）。

*提示：*使用@Entity注解的类，必须实现BuguEntity接口。
===@Id===
映射到MongoDB中的"_id"，必须为String类型。
===@Property===
该注解可以省略。它用来映射基本数据类型，包括：String、int、long、float、double、boolean、char、Date等，以及这些基本数据类型组成的数组、List、Set。

@Property有一个参数name，用于指定映射到MongoDB collection中某个field。参数name可以省略，表示采用与Entity的Field相同的名称。
===@Embed===
表示该属性是一个嵌入的对象。其参数name的含义与@Property中的相同。
===@EmbedList===
表示该属性是一组嵌入的对象。其参数name的含义与@Property中的相同。

*提示：*用@EmbedList注解的List，必须使用泛型。
===@Ref===
表示对另一个对象的引用，在MongoDB中保存的是形如"father" : {"$ref" : "father", "$id" : ObjectId("4dcb4d1d3febc6503e4e5933")}这样的一个DBRef。

@Ref有一个参数name，含义与@Property的参数name一样。

@Ref还有一个参数lazy，值为true或false，默认为true。用于指定是否关联取出该引用对象。若lazy=true，表示只取出该引用对象的id，而不取出其它属性。若lazy=false，表示同时取出该引用对象的所有属性。
===@RefList===
表示对另一个对象的引用的集合。其参数name和lazy的含义与@Ref中的类似。

*提示：*用@RefList注解的List，需要使用泛型。
===@Ignore===
表示该属性不需要被映射。当保存实体时，该属性不会保存至MongoDB；同样，该属性也不会从MongoDB中取出。

==步骤二：连接数据库==
在能够对MongDB进行操作之前，需要使用BuguConnection连接MongoDB数据库。如：
{{{
BuguConnection conn = BuguConnection.getInstance();
conn.setHost("192.168.0.100");
conn.setPort(27017);
conn.setDatabase("mydb");
conn.setUsername("username");
conn.setPassword("password");
conn.connect();
}}}
或者：
{{{
BuguConnection conn = BuguConnection.getInstance();
conn.connect("192.168.0.100", 27017, "mydb", "username", "password");
}}}

==步骤三：使用BuguDao进行数据库操作==
你需要编写自己的Dao，如FooDao，来操作Foo相关的数据，FooDao需要继承自BuguDao，并且，在FooDao的构造函数中，需要传递Foo.class，如下：
{{{
public class FooDao extends BuguDao{
    public FooDao(){
        super(Foo.class);
    }
}
}}}
BuguDao中，提供了大量的常用的方法，用于操作MongoDB的Collection，包括：

insert()

save()

remove()

removeAll()

update()

set()

inc()

push()

pull()

exists()

findOne()

findAll()

find()

cache()

count()

distinct()

mapReduce()

......

上面这些方法的用法都比较直观。其中有2点值得特别指出：

*1、*findAll()、find()等方法，在排序方面，除了支持标准的DBObject外，还支持使用形如"level:1"、"createTime:-1"这样的字符串进行单一条件排序。这能为你编写程序带来方便。

*2、*对于系统中的常用的基本数据，比如新闻系统中的新闻类别，可以用cache()方法将其取出并缓存起来。当然，使用cache方法的前提是，你设置了BuguConnection中的cacheTimeout值，例如，设置为30分钟：
{{{
BuguConnection.getInstance().setCacheTimeout(30L*60L*1000L)。
}}}
*注意*：请谨慎使用cache。一般来说，只对 *数据量小、常用的、系统基础数据* 使用cache。

你自己编写的Dao，通过继承自BuguDao，可以直接使用BuguDao中的方法，也可以通过组合这些方法，实现更复杂的函数。如：
{{{
public class FooDao extends BuguDao{
    public FooDao(){
        super(Foo.class);
    }
    public long coutByLowLevel(int level){
        DBObject query = QueryBuilder.start("level").greaterThan(level).get();
        return this.count(query);
    }
    ...other functions...
}
}}}
{{{
Foo foo = ...
FooDao fDao = new FooDao();
fDao.save(foo);
int count = fDao.countByLowLevel(9);
fDao.remove(foo);
}}}

==辅助转换工具：BuguMapper==
在某些地方，你需要使用BuguMapper来进行数据转换。BuguMapper提供了3个方法：

fromDBObject()

toDBObject()

toDBRef()

一个例子如下：
{{{
public class FooDao extends BuguDao{
    ...
    public Foo getByFather(FatherFoo father){
        DBObject query = new BasicDBObject();
        query.put("father", new BuguMapper().toDBRef(father));
        return (Foo)this.findOne(query);
    }
    ...
}
}}}
另外，对于@Ref、@RefList注解的属性，默认lazy=true，只取出其值的id，而不取出其它属性值。当你要用到其它属性值的时候，可以使用BuguMapper的fetch方法，将@Ref、@RefList的属性值全部取出。例子如下：
{{{
...
Foo foo = fooDao.findOne(id);
BuguMapper mapper = new BuguMapper();
mapper.fetch(foo, "children");
...
List list = fooDao.findAll();
mapper.fetch(list, "father");
}}}


=2、Lucene索引=
在Lucene索引方面，BuguMongo提供了：

5个注解：@Indexed、@IndexProperty、@IndexEmbed、@IndexRef、@IndexFilter

3个类：BuguIndex、BuguParser、BuguSearcher

==步骤一：在Entity上加注解==
代码例子如下：
{{{
import com.bugull.mongo.BuguEntity;
import com.bugull.mongo.annotations.Entity;
import com.bugull.mongo.annotations.Embed;
import com.bugull.mongo.annotations.Id;
import com.bugull.mongo.annotations.Ref;
import com.bugull.mongo.lucene.annotations.Indexed;
import com.bugull.mongo.lucene.annotations.IndexProperty;
import com.bugull.mongo.lucene.annotations.IndexEmbed;
import com.bugull.mongo.lucene.annotations.IndexRef;
import com.bugull.mongo.lucene.annotations.IndexFilter;
import com.bugull.mongo.lucene.annotations.Compare;
import java.util.List;

@Entity(name="foo")
@Indexed
public class Foo implements BuguEntity{
    @Id
    private String id;
    @IndexProperty(analyze=true)
    private String introduce;
    @Embed
    @IndexEmbed
    private EmbedFoo embed;
    @Ref
    @IndexRef
    private FatherFoo father;
    @IndexFilter(compare=Compare.IS_EQUALS,value="true")
    private boolean valid;
    ...getter and setter...
}

public class EmbedFoo {
    @IndexProperty
    private float x;
    @IndexProperty
    private int y;
    ...getter and setter
}

@Entity(name="father")
public class FatherFoo implements BuguEntity{
    @Id
    private String id;
    @IndexProperty(analyze=true)
    private String name;
    ...getter and setter...
}
}}}
各个注解的含义如下：

===@Indexed===
表示需要对该Entity建索引。该Entity上必须要有@Entity和@Id注解，@Indexed才能起作用。
===@IndexProperty===
表示需要索引的属性。该注解有2个参数：analyze和store，都是boolean型，analyze表示是否需要分词，store表示是否需要存储，默认值都是false。

@IndexProperty支持的数据类型包括：String、char、boolean、int、long、float、double、Date等基本数据类型。其中，数值、日期类型可以用于范围查询和排序。

@IndexProperty还支持上述基本数据类型组成的数组、List、Set等。这些集合中的元素，不管是什么数据类型，都会连结成一个字符串，然后加以索引。可以用@IndexProperty的join参数设置连接字符。默认是用分号";"进行字符串连结。
===@IndexEmbed===
表示需要嵌入对该Embed属性的索引。
===@IndexRef===
表示需要嵌入对该Ref属性的索引。

*提示：*BuguMongo不支持@EmbedList、@RefList类型属性的索引。
===@IndexFilter===
表示只有满足该条件的实体才会被索引，否则不创建索引。在一个实体上可以有多个@IndexFilter。

@IndexFilter有2个参数：compare和value。compare表示比较操作，是枚举类型Compare。value是比较的值，是字符串，会相应的解析成该属性类型的值。

compare有多个枚举值，它们的含义和所支持的数据类型如下：

Compare.IS_EQUALS——等于（==）。支持String、boolean、int、long、float、double、char。

Compare.NOT_EQUALS——不等于（!=）。支持String、boolean、int、long、float、double、char。

Compare.GREATER_THAN——大于（>）。支持int、long、float、double。

Compare.GREATER_THAN_EQUALS——大于等于（>=）。支持int、long、float、double。

Compare.LESS_THAN——小于（<）。支持int、long、float、double。

Compare.LESS_THAN_EQUALS——小于等于（<=）。支持int、long、float、double。

Compare.IS_NULL——为空（==null）。支持Object类型，包括String。这时不需要value参数。

Compare.NOT_NULL——不为空（!=null）。支持Object类型，包括String。这时不需要value参数。

==步骤二：设置索引参数==
代码例子如下：
{{{
BuguIndex index = BuguIndex.getInstance();
index.setDirectoryPath("/root/lucene_index/");
index.setIndexReopenTask(30L*1000L);
}}}
代码中各个函数的含义都很直观。其中：

BuguMongo使用FSDirectory存储索引，通过setDirectoryPath()可以设置索引文件存放的位置。

setIndexReopenTask(long milli)的参数以毫秒为单位，表示索引刷新的时间周期，该参数值根据应用的情况而定，如30秒：30L*1000L。

BuguIndex默认使用StandardAnalyzer，你可以用setAnalyzer()来设置你所需要的Analyzer。

另外，如果你不想使用默认的Lucene版本，可以用setVersion()来设置Lucene索引的版本，用getVersion()可以获得版本号。

==步骤三：搜索==
通过上面的设置，BuguMongo能够实现Entity和Lucene索引之间的自动同步，你只要实现搜索就行了。最基本的搜索的例子如下：
{{{
BuguParser parser = new BuguParser();
Query query = parser.parse("introduce", "谷歌");
BuguSearcher searcher = new BuguSearcher(Foo.class);
searcher.setQuery(query);
searcher.setSort(...);
searcher.setPageNumber(1);
searcher.setPageSize(20);
searcher.setMaxPage(50);
List list = searcher.search();
int count = searcher.getResultCount();
for(Object obj : list){
    Foo foo = (Foo)obj;
    ...
}
}}}
setMaxPage(maxPage)，表示最多返回搜索结果的前maxPage页。设置该参数的原因是：如果返回所有的搜索结果，当数据量太大的时候，会导致性能问题。

pageNumber、pageSize、maxPage的值都可以不设置，默认值为分别为：1、20、50。

如果不排序，可以不用setSort()。

BuguParser类提供了对各种数据类型的查询支持，包括数值查询、数值和日期查询等，还提供了MultiFieldQueryParser的功能，参见下面的例子。

对于通过@IndexEmbed和@IndexRef嵌入的索引，索引的field名称需要加上该属性的名称作为前缀，如：father.name。参见下面的例子。

{{{
BuguParser parser = new BuguParser();
Query strQuery = parser.parse(new String[]{"introduce","father.name"},"谷歌");
Query xQuery = parser.parse("embed.x",3.14f);
Query yQuery = parser.parse("embed.y", 100, 300);
BooleanQuery bQuery = new BooleanQuery();
bQuery.add(strQuery, Occur.SHOULD);
bQuery.add(xQuery, Occur.MUST_NOT);
bQuery.add(yQuery, Occur.MUST);
BuguSearcher searcher = new BuguSearcher(Foo.class);
searcher.setQuery(bQuery);
List list = searcher.search();
int count = searcher.getResultCount();
for(Object obj : list){
    Foo foo = (Foo)obj;
    ...
}
}}}

==辅助工具：重建索引==
在某些情况下，由于特殊的原因，Lucene索引文件没有与MongoDB中的记录一一对应，这时，需要对MongoDB中的记录重新建立Lucene索引。BuguMongo提供了一个类IndexRebuilder来实现该功能。IndexRebuilder实现了Runnable接口，可以利用它生成多个线程。代码例子如下：
{{{
IndexRebuilder t1 = new IndexRebuilder(Foo.class);
new Thread(t1).start();
...
IndexRebuilder t2 = new IndexRebuilder(MyEntity.class);
new Thread(t2).start();
}}}


=3、GridFS文件存取=

BuguMongo提供了4个类，来简化GridFS文件的上传和获取。

上传：Uploader、ImageUploader、Watermark。

读取：UploadedFileServlet

==文件上传==
以Struts2开发的新闻系统为例，发布一篇新闻的时候，同时上传新闻的附件（比如.doc文件），那么，在Struts2的Action中，代码这样写：
{{{
import com.bugull.mongo.fs.Uploader;
...
public class CreateNewsAction extends ActionSupport{

    private File file;  //struts接收到的文件
    private String fileFileName;  //struts接收到的文件名
    private News news;
    private NewsDao newsDao;

    public String execute(){
        Uploader uploader = new Uploader(file, fileFileName);
        uploader.save();
        news.setAttachment(uploader.getFilename());
        newsDao.save(news);
        return SUCCESS;
    }
    ...
}
}}}
uploader.getFilename()，返回的是，文件经过保存以后，系统生成的文件名（含扩展名），格式如：2011070799999999999999.doc，其中，20110707为日期，9999999999999为当前时间的long值。news实体中attachment值，就是这个字符串。

还可以为上传的文件设置其它属性。例如，设置文件的作者：
{{{
Uploader uploader = new Uploader(file, fileFileName);
uploader.setAttribute("author", "Frank");
uploader.save();
}}}

==图片文件的上传==
图片上传使用类ImageUploader，它继承自Uploader，除了具备上面讲的Uploader的功能以外，ImageUploader还能实现图片加水印、图片压缩。

===图片加水印===
图片上传的时候，可以自动加上水印，代码如下：
{{{
import com.bugull.mongo.fs.Watermark;
import com.bugull.mongo.fs.ImageUploader;
...
public class CreateProductAction extends ActionSupport{

    private File img;
    private String imgFileName;
    private Product product;
    private ProductDao productDao;

    public String execute(){
        Watermark watermark = new Watermark();
        watermark.setFilePath("/root/website/images/watermark.png");
        watermark.setAlign(Watermark.CENTER);
        ImageUploader uploader = new ImageUploader(img, imgFileName);
        uploader.save(watermark);
        product.setPicture(uploader.getFilename());
        productDao.save(product);
        return SUCCESS;
    }
    ...
}
}}}
watermark.setFilePath(filePath)设置水印文件的路径，该路径是操作系统的绝对路径。

watermark.setAlign(align)设置水印图片的对其位置，Watermark.CENTER表示水印位于图片正中央，Watermark.BOTTOM_RIGHT表示水印位于图片的右下角。

如果是位于右下角，则还可以用watermark.setBottom(int bottom)，watermark.setRight(int right)来设置水印图片和原图片之间的下边距、右边距。

为保证水印效果，水印图片最好是.png格式的，背景是透明的，图片内容是半透明的。

===图片压缩===
图片上传的时候，经常还需要将该图片压缩、保存成若干份，代码例子如下：
{{{
import com.bugull.mongo.fs.ImageUploader;
...
public class CreateProductAction extends ActionSupport{

    private File img;
    private String imgFileName;
    private Product product;
    private ProductDao productDao;

    public String execute(){
        ImageUploader uploader = new ImageUploader(img, imgFileName);
        uploader.save();
        uploader.compress("medium", 300, 300);
        uploader.compress("small", 100, 100);
        product.setPicture(uploader.getFilename());
        productDao.save(product);
        return SUCCESS;
    }
    ...
}
}}}
public void compress(String dimension, int maxWidth, int maxHeight) 方法中，dimension是指图片尺寸的类型，用来区分同一图片的不同尺寸的拷贝。经过compress方法压缩保存后的图片文件，和原图有相同的filename，例如，同样是2011070799999999999999.jpg。

===文件的获取===
保存到GridFS中的文件，可以通过UploadedFileServlet来获取，在web.xml中配置如下：
{{{
<servlet>
    <servlet-name>UploadedFile</servlet-name>
    <servlet-class>com.bugull.mongo.fs.UploadedFileServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>UploadedFile</servlet-name>
    <url-pattern>/UploadedFile</url-pattern>
</servlet-mapping>
}}}
然后，可以通过如下的URL链接来获取文件：
{{{
http://www.domain.com/UploadedFile/xxxx.jpg
或者：
http://www.domain.com/UploadedFile/key/value/xxxx.jpg
http://www.domain.com/UploadedFile/key1/value1/key2/value2/xxxx.jpg
}}}
其中：

xxxx.jpg表示文件名，必须提供。

key、value表示属性名称、属性值。

例如：
{{{
http://www.domain.com/UploadedFile/dimension/small/2011070799999999999999.jpg
http://www.domain.com/UploadedFile/author/Frank/dimension/small/2011070799999999999999.jpg
}}}
*需要特别注意*的是，经过ImageUploader.compress()压缩后的图片，默认有一个尺寸属性"dimension"。