#summary DAO操作

= DAO操作 =
像[ObjectDocumentMapping 对象-文档映射]中那样，给实体类加上了注解，并且实现了BuguEntity接口，接下来就可以使用BuguDao类操作该实体了。

== BuguDao构造函数 ==
你需要编写自己的Dao，如FooDao，来操作Foo相关的数据。FooDao需要继承自BuguDao，并且，在FooDao的构造函数中，需要传递Foo.class，如下：
{{{
public class FooDao extends BuguDao<Foo> {
    public FooDao(){
        super(Foo.class);
    }
}
}}}

== 插入 ==
BuguDao中有如下方法可用于插入数据：
{{{
public WriteResult insert(T t)

public WriteResult insert(List<T> list)  //批量插入

public WriteResult save(T t)  //如果t中没有ID值，则为插入，若有ID值，则为修改。用户自定义ID除外。
}}}
其中，当使用save(obj)方法时，如果obj中的id值为null，则实际执行数据库插入操作；如果obj中的id值不为null，则实际执行数据库修改操作。（@Id的type=IdType.USER_DEFINE的情况除外）

例：
{{{
Foo foo = new Foo();
foo.setName("Frank");
foo.setLevel(10);

FooDao dao = new FooDao();
dao.save(foo);
String id = foo.getId();  //保存至数据库后，foo中有id值了
}}}

== 修改 ==
{{{
public WriteResult save(T t)

/* 修改属性值 */
public WriteResult set(T t, Map values)

public WriteResult set(String id, Map values)

public WriteResult set(BuguQuery query, Map values)

public WriteResult set(T t, String key, Object value)

public WriteResult set(String id, String key, Object value)

/* 增加、减少数值 */

public WriteResult inc(T t, String key, Object value)

public WriteResult inc(String id, String key, Object value)

public WriteResult inc(BuguQuery query, String key, Object value)

/* 删除属性列 */

public WriteResult unset(T t, String key)

public WriteResult unset(String id, String key)

public WriteResult unset(BuguQuery query, String key)
}}}
例：
{{{
FooDao dao = new FooDao();
Foo foo = dao.query().is("name", "Frank").result();

dao.set(foo, "level", 9);  //把foo的level值修改为9

//把foo的name改为“John”，level值改为20
Map newValues = new HashMap();
newValues.put("name", "John");
newValues.put("level", 20);
dao.set(foo, newValues);

dao.inc(foo, "level", 100);  //把foo的level值增加100
dao.inc(foo, "level", -50);  //把foo的level值减少50

dao.unset(foo, "level");  //移除foo的属性列level
}}}

== 删除 ==
{{{
public void drop()  //删除整个Collection

public WriteResult remove(T t)

public WriteResult remove(String id)

public WriteResult remove(String... ids)  //批量删除

public WriteResult remove(String key, Object value)  //按条件删除

public WriteResult remove(BuguQuery query)  //按条件删除
}}}

== 数组、列表操作==
{{{
public WriteResult push(T t, String key, Object value)

public WriteResult push(String id, String key, Object value)

public WriteResult pull(T t, String key, Object value)

public WriteResult pull(String id, String key, Object value)
}}}
对于数组、List、Set，在MongoDB中都被保存成数组，可以用push、pull方法对其进行操作。

*注：*

上述对数据库的修改操作，都有一个返回值WriteResult，代表了操作的结果。该类由mongoDB Java Driver提供，其详细信息，可以[http://api.mongodb.org/java/current/com/mongodb/WriteResult.html 查看这里]。

== 查询 ==

查询需要用到BuguQuery类。先看看BuguQuery类中有些什么方法：

*生成查询条件*：
{{{
public BuguQuery<T> is(String key, Object value)

public BuguQuery<T> notEquals(String key, Object value)

public BuguQuery<T> greaterThan(String key, Object value)

public BuguQuery<T> greaterThanEquals(String key, Object value)

public BuguQuery<T> lessThan(String key, Object value)

public BuguQuery<T> lessThanEquals(String key, Object value)

public BuguQuery<T> in(String key, Object... values)

public BuguQuery<T> in(String key, List list)

public BuguQuery<T> notIn(String key, Object... values)

public BuguQuery<T> notIn(String key, List list)

public BuguQuery<T> all(String key, Object... values)

public BuguQuery<T> size(String key, int value)

public BuguQuery<T> mod(String key, int divisor, int remainder)

public BuguQuery<T> existsField(String key)

public BuguQuery<T> notExistsField(String key){

public BuguQuery<T> regex(String key, String regex)

public BuguQuery<T> where(String whereStr)

public BuguQuery<T> or(BuguQuery... qs)

public BuguQuery<T> and(BuguQuery... qs)
}}}
*地理空间数据查询*：
{{{
public BuguQuery<T> near(String key, double x, double y)

public BuguQuery<T> near(String key, double x, double y, double maxDistance)

public BuguQuery<T> withinCenter(String key, double x, double y, double radius)

public BuguQuery<T> withinBox(String key, double x1, double y1, double x2, double y2)
}}}
*设置查询参数*:
{{{
public BuguQuery<T> slice(String key, long num)

public BuguQuery<T> returnFields(String... fieldNames)

public BuguQuery<T> notReturnFields(String... fieldNames)

public BuguQuery<T> sort(String orderBy)

public BuguQuery<T> pageNumber(int pageNumber)

public BuguQuery<T> pageSize(int pageSize)
}}}
*返回查询结果*：
{{{
public T result()  //返回一个实体

public List<T> results()  //返回多个实体

public long count()

public boolean exists()

public List distinct(String key)
}}}

== 创建BuguQuery ==
通过调用BuguDao中的query()方法，就可以创建一个BuguQuery对象：
{{{
public class FooDao extends BuguDao<Foo> {
    public FooDao(){
        super(Foo.class);
    }
    ...
}

FooDao dao = new FooDao();
BuguQuery<Foo> q = dao.query();
...
}}}

== 用BuguQuery实现查询 ==
=== 支持连缀书写形式 ===
{{{
List<Foo> list = dao.query().greaterThan("level", 10).notEquals("name", "Frank").results();
}}}

=== 支持分页 ===
{{{
List<Foo> list = dao.query().greaterThan("level", 10).notEquals("name", "Frank").pageNumber(1).pageSize(20).results();
}}}

=== 支持指定返回、不返回某些字段 ===
{{{
//只返回id、name、level三个字段
BuguQuery query1 = dao.query().greaterTan("level", 10).returnFields("name", "level") ;
//不返回detail、comments这两个字段
BuguQuery query2 = dao.query().greaterThan("level", 10).notReturnFields("detail", "comments");  
}}}

=== 支持Entity对象作为查询条件 ===
{{{
FatherDao fDao = new FatherDao();
FatherFoo father = fDao.query().is("id", "4dcb4d1d3febc6503e4e5933").result();

Foo foo = dao.query().is("father", father).result();  //用FatherFoo对象作为查询条件
}}}

=== 支持字符串形式的排序 ===
{{{
List<Foo> list = dao.query().in("name", "Frank", "John").sort("{level:1, timestamp: -1}").results();
}}}
对于排序字符串的书写规则，请[http://code.google.com/p/bugumongo/wiki/ObjectDocumentMapping#排序字符串 参考这里]。

=== 支持多个条件的and、or布尔组合查询 ===
{{{
BuguQuery<Foo> q1 = dao.query().greaterThan("level", 10);
BuguQuery<Foo> q2 = dao.query().is("name", "John");
List<Foo> list = dao.query().or(q1, q2).results();
}}}
*注*：几乎很少需要用到and操作。BuguQuery的连缀书写形式，就是按多个条件的“与”逻辑进行组合的。一个需要用到and操作的例子如下，它用来连接两个or条件：
{{{
BuguQuery q1 = dao.query().is("level", 10);
BuguQuery q2 = dao.query().is("level", 20);
BuguQuery or1 = dao.query().or(q1, q2);
BuguQuery q3 = dao.query().is("name", "Frank");
BuguQuery q4 = dao.query().is("name", "John");
BuguQuery or2 = dao.query().or(q3, q4);
List list = dao.query().and(or1, or2).results();
}}}


==注意事项==
使用DAO操作MongoDB时，应该使用数据库的字段名称，而不是Java的属性名称。

比如：
{{{
@Property(name="total_score")
private int totalScore;
}}}
那么，操作数据库的时候，应该是：
{{{
list = dao.query().is("total_score", 1000).results();    //注意：不是totalScore
}}}
一种较好的习惯是：尽量不设置@Property、@Embed、@EmbedList、@Ref、@RefList等注解的name属性，使得数据库的字段名称，与Java的属性名称，保持一致。