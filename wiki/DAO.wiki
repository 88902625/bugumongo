#summary DAO操作

= DAO操作 =
像[ObjectDocumentMapping 对象-文档映射]中那样，给实体类加上了注解，并且实现了BuguEntity接口，接下来就可以使用BuguDao类操作该实体了。

== BuguDao构造函数 ==
你需要编写自己的Dao，如FooDao，来操作Foo相关的数据。FooDao需要继承自BuguDao，并且，在FooDao的构造函数中，需要传递Foo.class，如下：
{{{
public class FooDao extends BuguDao<Foo> {
    public FooDao(){
        super(Foo.class);
    }
}
}}}

== 插入 ==
BuguDao中有如下方法可用于插入数据：
{{{
public void insert(T t)

public void insert(List<T> list)  //批量插入

public void save(T t)  //如果t中没有ID值，则为插入，若有ID值，则为修改。用户自定义ID除外。
}}}
其中，当使用save(obj)方法时，如果obj中的id值为null，则实际执行数据库插入操作；如果obj中的id值不为null，则实际执行数据库修改操作。（@Id的type=IdType.USER_DEFINE的情况除外）

例：
{{{
Foo foo = new Foo();
foo.setName("Frank");
foo.setLevel(10);

FooDao dao = new FooDao();
dao.save(foo);
String id = foo.getId();  //保存至数据库后，foo中有id值了
}}}

== 修改 ==
{{{
public void save(T t)

/* 修改属性值 */
public void set(T t, Map values)

public void set(String id, Map values)

public void set(BuguQuery query, Map values)

public void set(T t, String key, Object value)

public void set(String id, String key, Object value)

/* 增加、减少数值 */

public void inc(T t, String key, Object value)

public void inc(String id, String key, Object value)

public void inc(BuguQuery query, String key, Object value)

/* 删除属性列 */

public void unset(T t, String key)

public void unset(String id, String key)

public void unset(BuguQuery query, String key)
}}}
例：
{{{
FooDao dao = new FooDao();
Foo foo = dao.query().is("name", "Frank").result();

dao.set(foo, "level", 9);  //把foo的level值修改为9

//把foo的name改为“John”，level值改为20
Map newValues = new HashMap();
newValues.put("name", "John");
newValues.put("level", 20);
dao.set(foo, newValues);

dao.inc(foo, "level", 100);  //把foo的level值增加100
dao.inc(foo, "level", -50);  //把foo的level值减少50

dao.unset(foo, "level");  //移除foo的属性列level
}}}

== 删除 ==
{{{
public void drop()  //删除全部

public void remove(T t)

public void remove(String id)

public void remove(String... ids)  //批量删除

public void remove(String key, Object value)  //按条件删除

public void remove(BuguQuery query)  //按条件删除
}}}

== 数组、列表操作==
{{{
public void push(T t, String key, Object value)

public void push(String id, String key, Object value)

public void pull(T t, String key, Object value)

public void pull(String id, String key, Object value)
}}}
对于数组、List、Set，在MongoDB中都被保存成数组，可以用push、pull方法对其进行操作。

== 查询 ==

查询需要用到BuguQuery类。先看看BuguQuery类中有些什么方法：

*生成查询条件*：
{{{
public BuguQuery<T> is(String key, Object value)

public BuguQuery<T> notEquals(String key, Object value)

public BuguQuery<T> greaterThan(String key, Object value)

public BuguQuery<T> greaterThanEquals(String key, Object value)

public BuguQuery<T> lessThan(String key, Object value)

public BuguQuery<T> lessThanEquals(String key, Object value)

public BuguQuery<T> in(String key, Object... values)

public BuguQuery<T> notIn(String key, Object... values)

public BuguQuery<T> all(String key, Object... values)

public BuguQuery<T> size(String key, int value)

public BuguQuery<T> mod(String key, int divisor, int remainder)

public BuguQuery<T> existsField(String key)

public BuguQuery<T> notExistsField(String key){

public BuguQuery<T> regex(String key, String regex)

public BuguQuery<T> or(BuguQuery... qs)

public BuguQuery<T> and(BuguQuery... qs)
}}}
*地理空间数据查询*：
{{{
public BuguQuery<T> near(String key, double x, double y)

public BuguQuery<T> near(String key, double x, double y, double maxDistance)

public BuguQuery<T> withinCenter(String key, double x, double y, double radius)

public BuguQuery<T> withinBox(String key, double x1, double y1, double x2, double y2)
}}}
*设置查询参数*:
{{{
public BuguQuery<T> sort(String orderBy)

public BuguQuery<T> pageNumber(int pageNumber)

public BuguQuery<T> pageSize(int pageSize)
}}}
*返回查询结果*：
{{{
public T result()  //返回一个实体

public List<T> results()  //返回多个实体

public long count()

public boolean exists()

public List distinct(String key)
}}}

== 创建BuguQuery ==
通过调用BuguDao中的query()方法，就可以创建一个BuguQuery对象：
{{{
public class FooDao extends BuguDao<Foo> {
    public FooDao(){
        super(Foo.class);
    }
    ...
}

FooDao dao = new FooDao();
BuguQuery<Foo> q = dao.query();
...
}}}

== 用BuguQuery实现查询 ==
=== 支持连缀书写形式 ===
{{{
List<Foo> list = dao.query().greaterThan("level", 10).notEquals("name", "Frank").results();
}}}

=== 支持分页 ===
{{{
List<Foo> list = dao.query().greaterThan("level", 10).notEquals("name", "Frank").pageNumber(1).pageSize(20).results();
}}}

=== 支持Entity对象作为查询条件 ===
{{{
FatherDao fDao = new FatherDao();
FatherFoo father = fDao.query().is("id", "4dcb4d1d3febc6503e4e5933").result();

Foo foo = dao.query().is("father", father).result();  //用FatherFoo对象作为查询条件
}}}

=== 支持字符串形式的排序 ===
{{{
List<Foo> list = dao.query().in("name", "Frank", "John").sort("{level:1, timestamp: -1}").results();
}}}
对于排序字符串的书写规则，请[http://code.google.com/p/bugumongo/wiki/ObjectDocumentMapping#排序字符串 参考这里]。

=== 支持多个条件的and、or布尔组合查询 ===
{{{
BuguQuery<Foo> q1 = dao.query().greaterThan("level", 10);
BuguQuery<Foo> q2 = dao.query().is("name", "John");
List<Foo> list = dao.query().or(q1, q2).results();
}}}
*注意*：and操作只有MongoDB 2.0以后才支持，而且，几乎很少需要用到and操作。BuguQuery的连缀书写形式，就是按多个条件的“与”逻辑进行组合的。一个需要用到and操作的例子如下，它用来连接两个or条件：
{{{
BuguQuery q1 = dao.query().is("level", 10);
BuguQuery q2 = dao.query().is("level", 20);
BuguQuery or1 = dao.query().or(q1, q2);
BuguQuery q3 = dao.query().is("name", "Frank");
BuguQuery q4 = dao.query().is("name", "John");
BuguQuery or2 = dao.query().or(q3, q4);
List list = dao.query().and(or1, or2).results();
}}}


==注意事项==
使用DAO操作MongoDB时，应该使用数据库的字段名称，而不是Java的属性名称。比如：
{{{
@Property(name="total_score")
private int totalScore;
}
}}}
那么，操作数据库的时候，应该是：
{{{
list = dao.query().is("total_score", 1000).results();
}}}
一种较好的习惯是：使Java的属性名称，与数据库的字段名称，保持一致。

== AdvancedDao ==
AdvancedDao是BuguDao的子类，它主要提供MapReduce功能，以及基于MapReduce实现的一些高级统计功能。但鉴于目前MongoDB的MapReduce性能不是很理想，如果您的数据量非常庞大，请谨慎使用。

AdvancedDao中的方法如下：

*统计：*
{{{
public double max(String key)

public double max(String key, BuguQuery query)

public double min(String key)

public double min(String key, BuguQuery query)

public double sum(String key)

public double sum(String key, BuguQuery query)
}}}
*分组：*
{{{
public Iterable<DBObject> group(GroupCommand cmd)

public Iterable<DBObject> group(DBObject key, DBObject query, DBObject initial, String reduce)

public Iterable<DBObject> group(DBObject key, DBObject query, DBObject initial, String reduce, String finalize)
}}}
*MapReduce：*
{{{
public Iterable<DBObject> mapReduce(MapReduceCommand cmd)

public Iterable<DBObject> mapReduce(String map, String reduce)

public Iterable<DBObject> mapReduce(String map, String reduce, DBObject query) 

public Iterable<DBObject> mapReduce(String map, String reduce, String outputTarget, MapReduceCommand.OutputType outputType, DBObject sort, DBObject query)

public Iterable<DBObject> mapReduce(String map, String reduce, String outputTarget, MapReduceCommand.OutputType outputType, DBObject sort, int pageNum, int pageSize, DBObject query)
}}}

示例代码：
{{{
//扩展自AdvancedDao
public class FooDao extends AdvancedDao{
    public FooDao(){
        super(Foo.class);
    }
}

FooDao dao = new FooDao();
double d = dao.max("embed.x");
}}}