#summary 对象-文档映射，DAO操作

=对象-文档映射=
在对象(Object，也称实体Entity)、文档(Document)之间实现自动转换，是BuguMongo的最核心功能，这能让你直接用面向对象的概念来操作MongoDB数据库，而不用去关心底层的数据库细节。

在这方面，BuguMongo提供了：

8个注解：@Entity、@Id、@Property、@Embed、@EmbedList、@Ref、@RefList、@Ignore

1个接口：BuguEntity

2个Dao类：BuguDao、AdvancedDao

1个查询类：Query

1个辅助类：BuguMapper

==1、定义Entity==
要使得某个Java Entity能和MongoDB Document实现相互转换，该Entity需要实现BuguEntity接口，并加上注解，如下：
{{{
import com.bugull.mongo.BuguEntity;
import com.bugull.mongo.annotations.Entity;
import com.bugull.mongo.annotations.Id;
import com.bugull.mongo.annotations.Property;
import com.bugull.mongo.annotations.Embed;
import com.bugull.mongo.annotations.EmbedList;
import com.bugull.mongo.annotations.Ref;
import com.bugull.mongo.annotations.RefList;
import java.util.List;

@Entity(name="foo")
public class Foo implements BuguEntity{
    @Id
    private String id;
    private String name;
    @Property
    private int level;
    @Embed
    private EmbedFoo embed;
    @EmbedList
    private List<EmbedFoo> embedList;
    @Ref
    private FatherFoo father;
    @RefList
    private List<ChildFoo> children;
    @Ignore
    private double sumScore;
    ...getter and setter...
}

public class EmbedFoo {
    private float x;
    private int y;
    ...getter and setter
}

@Entity(name="father")
public class FatherFoo implements BuguEntity{
    @Id
    private String id;
    private Date date;
    @Ref
    private FatherFoo father;
    ...getter and setter...
}

@Entity(name="child")
public class ChildFoo implements BuguEntity{
    @Id
    private String id;
    private List<String> list;
    ...getter and setter...
}
}}}
各个注解的含义如下：
===@Entity===
表示需要映射到MongoDB中的一个实体。该注解有3个参数：

name——String型，表示其在MongoDB中的collection的名称。name可以省略，默认使用类名的全小写。

capped——boolean型，表示该Entity类对应的是Capped Collection，缺省值为false。

capSize——long型，设置Capped Collection的大小，缺省值为10M（10L*1024L*1024L）。

*提示：*使用@Entity注解的类，必须实现BuguEntity接口。
===@Id===
映射到MongoDB中的"_id"，必须为String类型。
===@Property===
该注解可以省略。它用来映射基本数据类型，包括：String、int、long、short、float、double、boolean、char、Date、Timestamp等，以及这些基本数据类型组成的数组、List、Set、Map。

@Property只有一个参数：

name——String型，用于指定映射到MongoDB collection中某个field。参数name可以省略，表示采用与Entity的Field相同的名称。
===@Embed===
表示该属性是一个嵌入的对象。其参数name的含义与@Property中的相同。
===@EmbedList===
表示该属性是一组嵌入的对象。其参数name的含义与@Property中的相同。

@EmbedList注解支持java.util.List、java.util.Set、java.util.Map，但都必须使用泛型。当使用Map的时候，嵌入对象只能作为Map的value，而不能作为key。
===@Ref===
表示对另一个对象的引用，在MongoDB中保存的是形如"father" : {"$ref" : "father", "$id" : ObjectId("4dcb4d1d3febc6503e4e5933")}这样的一个DBRef。

@Ref有2个参数：

name——含义与@Property的参数name一样。

lazy——boolean型，用于指定是否关联取出该引用对象。若lazy=true，表示只取出该引用对象的id，而不取出其它属性。若lazy=false，表示同时取出该引用对象的所有属性。缺省值为true。
===@RefList===
表示对另一个对象的引用的集合。

@RefList有3个参数：

name——含义与@Property的参数name一样。

lazy——boolean型，用于指定是否关联取出该引用对象。若lazy=true，表示只取出该引用对象的id，而不取出其它属性。若lazy=false，表示同时取出该引用对象的所有属性。缺省值为true。

sort——String型，用于取出该List或Set属性时，使用的排序规则，其形式是："{'level':1}"，或"{'level':1, 'timestamp':-1}"这样的多个排序规则。如果不排序，则不用设置sort值。

当lazy=false，或者使用BuguMapper.fetch()取出@RefList注解的属性时，都会使用其sort参数。

@RefList注解支持java.util.List、java.util.Set、java.util.Map，但都必须使用泛型。当使用Map的时候，引用对象只能作为Map的value，而不能作为key。
===@Ignore===
表示该属性不需要被映射。当保存实体时，该属性不会保存至MongoDB；同样，该属性也不会从MongoDB中取出。

==2、使用BuguDao进行操作==
===2.1、Dao构造函数===
你需要编写自己的Dao，如FooDao，来操作Foo相关的数据，FooDao需要继承自BuguDao，并且，在FooDao的构造函数中，需要传递Foo.class，如下：
{{{
public class FooDao extends BuguDao{
    public FooDao(){
        super(Foo.class);
    }
}
}}}

===2.2、BuguDao中的方法===
BuguDao的使用非常灵活方便，它提供了大量的常用的方法，用于操作MongoDB的Collection，包括：

*插入：*
{{{
public void insert(BuguEntity obj)

public void insert(List<BuguEntity> list)  //批量插入
}}}
*保存：*
{{{
public void save(BuguEntity obj)  //如果obj中没有ID值，则为插入，若有ID值，则为修改。
}}}
*删除：*
{{{
public void drop()

public void remove(BuguEntity obj)

public void remove(String id)

public void remove(String... ids)  //批量删除

public void remove(String key, Object value)

public void remove(DBObject query)
}}}
*修改：*
{{{
public void update(BuguEntity obj, DBObject dbo)

public void update(String id, DBObject dbo)

public void update(DBObject query, DBObject dbo)

public void set(BuguEntity obj, String key, Object value)

public void set(String id, String key, Object value)

public void inc(BuguEntity obj, String key, Object value)

public void inc(String id, String key, Object value)

public void push(BuguEntity obj, String key, Object value)

public void push(String id, String key, Object value)

public void pull(BuguEntity obj, String key, Object value)

public void pull(String id, String key, Object value)
}}}
*判断是否存在：*
{{{
public boolean exists(String key, Object value)

public boolean exists(DBObject query)

public boolean exists(BuguEntity obj, String key, Object value)
}}}
*查找一个：*
{{{
public Object findOne(String id)

public Object findOne(String key, Object value)

public Object findOne(DBObject query)
}}}
*查找全部：*
{{{
public List findAll()

public List findAll(String orderBy)

public List findAll(DBObject orderBy)

public List findAll(int pageNum, int pageSize)

public List findAll(String orderBy, int pageNum, int pageSize)

public List findAll(DBObject orderBy, int pageNum, int pageSize)
}}}
*按条件查找：*
{{{
public List find(String key, Object value)

public List find(DBObject query)

public List find(String key, Object value, String orderBy)

public List find(DBObject query, String orderBy)

public List find(DBObject query, DBObject orderBy)

public List find(String key, Object value, int pageNum, int pageSize)

public List find(DBObject query, int pageNum, int pageSize)

public List find(String key, Object value, String orderBy, int pageNum, int pageSize)

public List find(DBObject query, String orderBy, int pageNum, int pageSize)

public List find(DBObject query, DBObject orderBy, int pageNum, int pageSize)
}}}
*统计：*
{{{
public long count()

public long count(String key, Object value)

public long count(DBObject query)

public List distinct(String key)

public List distinct(String key, DBObject query)
}}}

通过继承BuguDao，可以直接使用BuguDao中的方法，也可以通过组合这些方法，实现更复杂的函数。

一个Dao的例子如下：
{{{
public class FooDao extends BuguDao{
    public FooDao(){
        super(Foo.class);
    }

    public long coutByLowLevel(int level){
        DBObject gt = new BasicDBObject("$gt", level);
        DBObject query = new BasicDBObject("level", gt);
        return this.count(query);
    }
}
}}}
然后可以这样调用FooDao中的方法：
{{{
FooDao fDao = new FooDao();

int count = fDao.countByLowLevel(9);    //level值大于9的记录条数

List list1 = fDao.findAll(1, 50);    //取出所有的Foo，并分页显示，显示第1页，每页50条

List list2 = fDao.find("embed.x", 3.14, "{level:-1}");    //取出embed属性的x=3.14的Foo，按level值从大到小排列

Foo foo = (Foo)fDao.findOne("4dcb4d1d3febc6503e4e5933");  //根据ID取出Entity

foo.setName("MyNewName");

fDao.save(foo);    //保存

fDao.inc(foo, "level", 1);    //level值增加1

fDao.set(foo, "embed.y", 100);    //把embed中y的值设为100

fDao.remove(foo);   //删除
}}} 

===2.3、排序===
正如前面的例子中显示的那样，BuguDao中的findAll()、find()等方法，在排序方面，除了支持标准的DBObject外，还支持使用形如"{level:-1}"这样的字符串进行排序，这能为编写程序带来方便。

排序字符串可以采用标准的JSON格式，如：
{{{
list = fDao.findAll("{'level': -1}");
}}}
若有多个排序条件，中间用逗号（,）隔开：
{{{
list = fDao.findAll("{'level':1, 'timestamp':-1}");
}}}

也可以使用简化的JSON格式：
{{{
list1 = fDao.findAll("{level:1}");
list2 = fDao.findAll("{level:1, timestamp:-1}");
}}}
或者简化成下面这样，也是支持的：
{{{
list1 = fDao.findAll("level:1");
list2 = fDao.findAll("level:1, timestamp:-1");
}}}

*注*：@RefList注解中的sort属性，也使用相同的书写规则。

===2.4、取得DBCollection===
BuguDao封装了大部分常用的DAO方法，你几乎不需要直接使用MongoDB Java Driver的DBCollection类。当然，在一些特殊情况下，你可能需要使用DBCollection，来执行BuguDao无法实现的操作，比如对collection重命名。这时，可以通过BuguDao的getCollection()方法，来获得其相对应的DBCollection实例：
{{{
FooDao dao = new FooDao();
DBCollection col = dao.getCollection();
col.rename("newName");
}}}

==3、辅助工具：BuguMapper==
BuguMapper是ODM的辅助工具类，主要提供2个静态方法，toDBRef()、fetch()：
{{{
public static DBRef toDBRef(BuguEntity obj)

public static void fetch(BuguEntity obj, String... names)

public static void fetch(List list, String... names)
}}}
===3.1、toDBRef()===
使用BuguDao中的find方法进行查询的时候，有一个需要特别注意的地方，那就是：当需要把@Ref、@RefList注解的属性作为查询条件的时候，需要用BuguMapper的toDBRef()方法，将Entity对象转换为DBRef，然后放入DBObject中。一个例子如下：
{{{
public class FooDao extends BuguDao{
    ...
    public Foo getByFather(FatherFoo father){
        DBObject query = new BasicDBObject();
        query.put("father", BuguMapper.toDBRef(father));
        return (Foo)this.findOne(query);
    }
    ...
}
}}}
*关键代码是下面这一行，需要特别注意*：
{{{
query.put("father", BuguMapper.toDBRef(father));
}}}

===3.2、fetch()===
对于@Ref、@RefList注解的属性，默认lazy=true，只取出其值的id，而不取出其它属性值。当你要用到其它属性值的时候，可以使用BuguMapper的fetch方法，将@Ref、@RefList的属性值全部取出。例子如下：
{{{
...
Foo foo = fooDao.findOne(id);
BuguMapper.fetch(foo, "children");    //把foo的children属性取出来
...
List list = fooDao.findAll();
BuguMapper.fetch(list, "father");
}}}
fetch()方法还支持级联取出属性，可以一级一级往下取，例如：
{{{
BuguMapper.fetch(list, "father.father");
}}}
当用fetch()方法取出@RefList注解标注的属性时，会根据注解上的sort属性进行排序。

==4、AdvancedDao==
BuguDao中提供了大量常用的方法，但如果要使用一些高级功能，比如MapReduce，那就要用到AdvancedDao。

AdvancedDao扩展自BuguDao，提供了一些高级功能（主要是MapReduce和聚合统计），详细内容请查看[http://code.google.com/p/bugumongo/wiki/TheAdvancedDao AdvancedDao]。

==5、Query查询==
正如你前面看到的那样，BuguDao中的find方法，使用的是MongoDB Java Driver中的DBObject类作为查询条件。

使用DBObject进行查询，某些时候可能存在如下问题：
 * 需要对MongoDB Java Driver有所掌握；
 * 生成复杂的查询条件比较麻烦，组合起来不太方便；
 * 需要把Entity实体转换成DBRef。

如果你不习惯使用DBObject来进行查询，没有关系，BuguMongo还提供了另一种选择，那就是[http://code.google.com/p/bugumongo/wiki/HowToQuery 使用Query]。