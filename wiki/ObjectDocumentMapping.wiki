#summary 对象-文档映射

=对象-文档映射=
在对象-文档映射方面，BuguMongo提供了：

8个注解：@Entity、@Id、@Property、@Embed、@EmbedList、@Ref、@RefList、@Ignore

2个类：BuguDao、BuguMapper

1个接口：BuguEntity

它们的含义都很直观。BuguMongo的使用，就是围绕着上述注解、类和接口来进行。

==步骤一：定义Entity==
要使得某个Java Entity能和MongoDB Document实现相互转换，该Entity需要实现BuguEntity接口，并加上注解，如下：
{{{
import com.bugull.mongo.BuguEntity;
import com.bugull.mongo.annotations.Entity;
import com.bugull.mongo.annotations.Id;
import com.bugull.mongo.annotations.Property;
import com.bugull.mongo.annotations.Embed;
import com.bugull.mongo.annotations.EmbedList;
import com.bugull.mongo.annotations.Ref;
import com.bugull.mongo.annotations.RefList;
import java.util.List;

@Entity(name="foo")
public class Foo implements BuguEntity{
    @Id
    private String id;
    @Property
    private int level;
    @Embed
    private EmbedFoo embed;
    @EmbedList
    private List<EmbedFoo> embedList;
    @Ref
    private FatherFoo father;
    @RefList
    private List<ChildFoo> children;
    @Ignore
    private double sumScore;
    ...getter and setter...
}

public class EmbedFoo {
    private float x;
    private int y;
    ...getter and setter
}

@Entity(name="father")
public class FatherFoo implements BuguEntity{
    @Id
    private String id;
    private Date date;
    @Ref
    private FatherFoo father;
    ...getter and setter...
}

@Entity(name="child")
public class ChildFoo implements BuguEntity{
    @Id
    private String id;
    private List<String> list;
    ...getter and setter...
}
}}}
各个注解的含义如下：
===@Entity===
表示需要映射到MongoDB中的一个实体。该注解有3个参数：

name——String型，表示其在MongoDB中的collection的名称。name可以省略，默认使用类名的全小写。

capped——boolean型，表示该Entity类对应的是Capped Collection，缺省值为false。

capSize——long型，设置Capped Collection的大小，缺省值为10M（10L*1024L*1024L）。

*提示：*使用@Entity注解的类，必须实现BuguEntity接口。
===@Id===
映射到MongoDB中的"_id"，必须为String类型。
===@Property===
该注解可以省略。它用来映射基本数据类型，包括：String、int、long、float、double、boolean、char、Date等，以及这些基本数据类型组成的数组、List、Set、Map。

@Property只有一个参数：

name——String型，用于指定映射到MongoDB collection中某个field。参数name可以省略，表示采用与Entity的Field相同的名称。
===@Embed===
表示该属性是一个嵌入的对象。其参数name的含义与@Property中的相同。
===@EmbedList===
表示该属性是一组嵌入的对象。其参数name的含义与@Property中的相同。

@EmbedList注解支持java.util.List、java.util.Set、java.util.Map，但都必须使用泛型。当使用Map的时候，嵌入对象只能作为Map的value，而不能作为key。
===@Ref===
表示对另一个对象的引用，在MongoDB中保存的是形如"father" : {"$ref" : "father", "$id" : ObjectId("4dcb4d1d3febc6503e4e5933")}这样的一个DBRef。

@Ref有2个参数：

name——含义与@Property的参数name一样。

lazy——boolean型，用于指定是否关联取出该引用对象。若lazy=true，表示只取出该引用对象的id，而不取出其它属性。若lazy=false，表示同时取出该引用对象的所有属性。缺省值为true。
===@RefList===
表示对另一个对象的引用的集合。

@RefList有3个参数：

name——含义与@Property的参数name一样。

lazy——boolean型，用于指定是否关联取出该引用对象。若lazy=true，表示只取出该引用对象的id，而不取出其它属性。若lazy=false，表示同时取出该引用对象的所有属性。缺省值为true。

sort——String型，用于取出该List或Set属性时，使用的排序规则，其形式是："level:1"，或"level:1, timestamp:-1"这样的多个排序规则。如果不排序，则不设置sort值。

当lazy=false，或者使用BuguMapper.fetch()取出@RefList注解的属性时，都会使用其sort参数。

@RefList注解支持java.util.List、java.util.Set、java.util.Map，但都必须使用泛型。当使用Map的时候，引用对象只能作为Map的value，而不能作为key。
===@Ignore===
表示该属性不需要被映射。当保存实体时，该属性不会保存至MongoDB；同样，该属性也不会从MongoDB中取出。

==步骤二：使用BuguDao进行数据库操作==
你需要编写自己的Dao，如FooDao，来操作Foo相关的数据，FooDao需要继承自BuguDao，并且，在FooDao的构造函数中，需要传递Foo.class，如下：
{{{
public class FooDao extends BuguDao{
    public FooDao(){
        super(Foo.class);
    }
}
}}}
BuguDao中，提供了大量的常用的方法，用于操作MongoDB的Collection，包括：

*插入：*
{{{
public void insert(BuguEntity obj)

public void insert(List<BuguEntity> list)  //批量插入
}}}
*保存：*
{{{
public void save(BuguEntity obj)  //如果obj中没有ID值，则为插入，若有ID值，则为修改。
}}}
*删除：*
{{{
public void removeAll()

public void remove(BuguEntity obj)

public void remove(String id)

public void remove(String key, Object value)

public void remove(DBObject query)
}}}
*修改：*
{{{
public void update(BuguEntity obj, DBObject dbo)

public void update(String id, DBObject dbo)

public void update(DBObject query, DBObject dbo)

public void set(BuguEntity obj, String key, Object value)

public void set(String id, String key, Object value)

public void inc(BuguEntity obj, String key, Object value)

public void inc(String id, String key, Object value)

public void push(BuguEntity obj, String key, Object value)

public void push(String id, String key, Object value)

public void pull(BuguEntity obj, String key, Object value)

public void pull(String id, String key, Object value)
}}}
*判断是否存在：*
{{{
public boolean exists(String key, Object value)

public boolean exists(DBObject query)

public boolean exists(BuguEntity obj, String key, Object value)
}}}
*查找一个：*
{{{
public Object findOne(String id)

public Object findOne(String key, Object value)

public Object findOne(DBObject query)
}}}
*查找全部：*
{{{
public List findAll()

public List findAll(String orderBy)

public List findAll(DBObject orderBy)

public List findAll(int pageNum, int pageSize)

public List findAll(String orderBy, int pageNum, int pageSize)

public List findAll(DBObject orderBy, int pageNum, int pageSize)
}}}
*按条件查找：*
{{{
public List find(String key, Object value)

public List find(DBObject query)

public List find(String key, Object value, String orderBy)

public List find(DBObject query, String orderBy)

public List find(DBObject query, DBObject orderBy)

public List find(String key, Object value, int pageNum, int pageSize)

public List find(DBObject query, int pageNum, int pageSize)

public List find(String key, Object value, String orderBy, int pageNum, int pageSize)

public List find(DBObject query, String orderBy, int pageNum, int pageSize)

public List find(DBObject query, DBObject orderBy, int pageNum, int pageSize)
}}}
*统计：*
{{{
public long count()

public long count(String key, Object value)

public long count(DBObject query)

public List distinct(String key)

public List distinct(String key, DBObject query)

public double max(String key)

public double max(String key, DBObject query)

public double min(String key)

public double min(String key, DBObject query)

public double sum(String key)

public double sum(String key, DBObject query)
}}}
*MapReduce：*
{{{
public Iterable<DBObject> mapReduce(MapReduceCommand command)

public Iterable<DBObject> mapReduce(String map, String reduce, DBObject query) 

public Iterable<DBObject> mapReduce(String map, String reduce, String outputTarget, MapReduceCommand.OutputType outputType, DBObject sort, DBObject query)

public Iterable<DBObject> mapReduce(String map, String reduce, String outputTarget, MapReduceCommand.OutputType outputType, DBObject sort, int pageNum, int pageSize, DBObject query)
}}}
上面这些方法的用法都比较直观。其中值得特别指出的是：findAll()、find()等方法，在排序方面，除了支持标准的DBObject外，还支持使用形如"level:1"、"level:1,createTime:-1"这样的字符串进行排序，这能为你编写程序带来方便。

你自己编写的Dao，通过继承自BuguDao，可以直接使用BuguDao中的方法，也可以通过组合这些方法，实现更复杂的函数。如：
{{{
public class FooDao extends BuguDao{
    public FooDao(){
        super(Foo.class);
    }
    public long coutByLowLevel(int level){
        DBObject query = QueryBuilder.start("level").greaterThan(level).get();
        return this.count(query);
    }
    ...other functions...
}
}}}
{{{
Foo foo = ...
FooDao fDao = new FooDao();
fDao.save(foo);
int count = fDao.countByLowLevel(9);
fDao.remove(foo);
}}}

==辅助工具：BuguMapper==
BuguMapper是ODM的辅助工具类，主要提供2个静态方法，toDBRef()、fetch：
{{{
public static DBRef toDBRef(BuguEntity obj)

public static void fetch(BuguEntity obj, String... names)

public static void fetch(List list, String... names)
}}}
===toDBRef()===
当你需要把@Ref、@RefList注解的属性作为查询条件的时候，需要用BuguMapper的toDBRef()方法，将Entity对象转换为DBRef，然后放入DBObject中。一个例子如下：
{{{
public class FooDao extends BuguDao{
    ...
    public Foo getByFather(FatherFoo father){
        DBObject query = new BasicDBObject();
        query.put("father", BuguMapper.toDBRef(father));
        return (Foo)this.findOne(query);
    }
    ...
}
}}}
*关键代码是下面这一行，需要特别注意*：
{{{
query.put("father", BuguMapper.toDBRef(father));
}}}

===fetch()===
对于@Ref、@RefList注解的属性，默认lazy=true，只取出其值的id，而不取出其它属性值。当你要用到其它属性值的时候，可以使用BuguMapper的fetch方法，将@Ref、@RefList的属性值全部取出。例子如下：
{{{
...
Foo foo = fooDao.findOne(id);
BuguMapper.fetch(foo, "children");    //把foo的children属性取出来
...
List list = fooDao.findAll();
BuguMapper.fetch(list, "father");
}}}
fetch()方法还支持级联取出属性，可以一级一级往下取，例如：
{{{
BuguMapper.fetch(list, "father.father");
}}}
当用fetch()方法取出@RefList注解标注的属性时，会根据注解上的sort属性进行排序。